apiVersion: apps/v1
kind: Deployment
metadata:
  name:  backend-webapp
spec:
  selector:
    matchLabels:
      app: backend-webapp
  replicas: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 0
      maxUnavailable: 1
  # pod definition section
  template:
    # metadata around the pod
    metadata:
      labels:
        app: backend-webapp
        # optional (nice to have)
        editor: vscode
    spec:
      # give pod 30 seconds to shit down after kube sends SIGTERM signal
      terminationGracePeriodSeconds: 30
      # Where will I tolerate my pods to run
      # These do not restrict the pod from running on nodes that do not have the provided taint
      tolerations:
      - key: workload
        operator: 'Equal'
        value: 'backend'
        effect: 'NoSchedule'
      # Where will my pods will run, and in what node label
      # We should add a toleration because the user nodes are tainted and will be not schedule the pods if the taint is not provided
      nodeSelector:
        kubernetes.azure.com/mode: user
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  app: backend-webapp
              topologyKey: kubernetes.io/hostname
      containers:
      # can be multiple containers since one pod scan contain multiple containers
      - name: backend-webapp
        # test image from docker registry, provided by nginx project
        image: acrdevzlj7yj.azurecr.io/weatherforecast-backend:latest
        ports: 
        - containerPort: 80
        imagePullPolicy: Always  # Always pull latest
        resources:
          requests:
            # node should have 128 megabytes available for pod to run into it
            # metrics are constantly sent from kubelet into metrics api (api server)
            # which updates etcd, 
            # kubernetes scheduler would then read the metrics and decide in which node the pod will be ran
            memory: "64Mi"
            # quarter of a CPU core is supposed to be allocated to this pod
            # this is used by kubernetes's scheduler for determining wether the pod can run into the node
            cpu: "250m"
          limits:
            memory: "1Gi"
            #1 core maimum allocated to each pod
            cpu: "1"
        # defning liveness and readiness probes
        livenessProbe:
          httpGet:
            path: /weatherforecast
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /weatherforecast
            port: 80
          initialDelaySeconds: 30
          timeoutSeconds: 10